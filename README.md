# GameObjectManager (가칭)

전체 순회, 삽입, 삭제, 탐색 속도가 매우 빠른 컨테이너입니다.  
제목은 GameObjectManager 라고 지었는데, GameObject를 관리하기 위한 컨테이너 쯤으로 불러도 괜찮습니다.  
이름에서 볼 수 있듯 게임 오브젝트를 관리하기 위해서 만든 특별한 자료구조입니다.  

게임에서 가장 빈번히 일어나는 작업 중 하나는 컨터이너의 순회입니다. 보통 게임 오브젝트들은 매 틱마다 자신의 고유의 일을 수행하기 위해 Update 혹은 Tick 이라는 함수를 수행합니다. 그러기 위해서는 컨테이너에 수많은 오브젝트들을 저장하여 전체 순회를 통해서 상태를 갱신하는 설게를 사용할 수 있습니다. 그러므로 컨테이너의 순회는 1초에 최소 60번은 발생하며, 순회의 속도는 게임의 성능을 판가름하는 요소가 될 수 있습니다. 순회의 복잡도는 일관적으로 O(N)의 복잡도를 보인다만, Cache Hit를 고려하면 실제로 연속된 공간에 저장되어있는 배열 (혹은 std::vector, std::array 등)이 오브젝트를 저장하는데 가장 적합한 자료구조일 것입니다.

일반적으로 자료구조의 성능을 판단하는 기준은 삽입, 삭제, 탐색의 시간복잡도입니다.  
저는 여기에 순회를 추가하여 자료구조의 성능을 평가하도록 하겠습니다.  

C++ 환경에서 가장 빈번하게 사용되는 배열 컨테이너인 std::vector의 성능은 다음과 같습니다. 

### **[std::vector]**
**순회: 일관적으로 O(N)**  
**삽입: 배열의 맨 뒤에 추가할 경우 O(1)**  
**삭제: 원하는 요소를 삭제하고 재배열시 O(N) + O(N) = O(N)**  
**탐색: 원하는 요소를 찾을 경우 최악의 경우 O(N)**  

가장 기본 형태의 배열은 데이터가 연속된 공간에 저장되어 있기에 순회 속도가 매우 빠릅니다.
그러나, 삭제와 탐색에 있어서 아쉬운 성능을 보입니다.
게임에서는 삭제와 탐색 또한 빈번하게 발생할 수 있기 때문에 O(N)이라는 복잡도는 살짝 부담스러울 수 있습니다.

그러면 이진 탐색을 사용할 수 있는 정렬된 벡터를 사용하여 최적화를 도모할 수 있습니다.
참고로 정렬된 벡터를 유지하기 위해서는 '키'가 필요한데
일반적으로 사용할 수 있는 것은 '오브젝트 고유 문자열의 해시값' 혹은 '오브젝트의 정수형 ID' 가 있습니다.

두 방식에는 각각 장단점이 있는데, 저는 문자열의 해시값을 키로 사용할 경우 해싱 비용이 부담된다고 판단하여 오브젝트의 정수형 ID를 키로 사용하는 방식을 선택했습니다. 그러나 이 방식은 디버깅이 어려울 수 있어, 상황에 따라 선호에 맞춰 선택하는 것이 좋습니다.

### **[정렬된 상태를 유지하는 std::vector]**
**순회: 일관적으로 O(N)**  
**삽입: 정렬 상태를 유지할 수 있는 위치를 탐색 후 삽입 최악의 경우 O(logN) + O(N) = O(N)**  
**삭제: 원하는 요소를 삭제하고 재배열시 최악의 경우 O(logN) + O(N) = O(N)**  
**탐색: 원하는 요소를 찾을 경우 최악의 경우 O(logN)**

정렬된 배열을 사용하면 삭제의 성능은 약간 향상되고, 탐색의 경우 유의미하게 빨라집니다.  
그러나 삽입의 성능은 매우 떨어집니다.  
정렬된 배열과 함께 오브젝트를 관리하는 경우 오브젝트 풀링 기법을 사용하면 꽤나 괜찮은 성능 향상을 얻어낼 수 있습니다.  
오브젝트 풀링이란 빈번하게 생성, 삭제되는 객체들을 미리 일정 크기만큼 생성하고 후에 한꺼번에 삭제하는 것을 의미합니다.  
게임에서 빈번한게 생성, 삭제되는 투사체, 적, 아이템 등을 맵 입장시 미리 생성하고 맵을 퇴장할 때 한 번에 삭제하는 설계를 사용한다면, 삽입과 삭제에 대한 성능 저하는 큰 병목이 아니게 될 것입니다.
탐색의 경우 확연하게 빠르기 때문에 오브젝트 풀링 기법과 정렬된 배열로 오브젝트를 관리하는 기법은 꽤나 유효합니다.

앞서 살펴봤듯, 오브젝트 풀링 기법을 사용하면 생성과 삭제의 복잡도가 게임 성능에 치명적인 영향을 미치지 않음을 알 수 있습니다. 이것은 컨테이너의 성능이 탐색 속도에 달려있다는 것을 의미하기도 합니다. 그러면 탐색 속도를 더 높일 방법을 모색하도록 합니다.

일반적으로 탐색이 가장 빠른 컨테이너는 해쉬 테이블입니다. C++ 에서는 std::unordered_map 이라는 형태로 해쉬 테이블을 제공합니다. 해시맵(HashMap)은 키와 값을 쌍으로 저장하는 자료구조로, 내부적으로 매우 큰 배열을 유지하며, 키를 해시 함수를 통해 배열의 인덱스로 변환하여 빠르게 접근하는 구조입니다. 해쉬맵은 성능은 다음과 같습니다.

### **[std::unordered_map]**
**순회: 일관적으로 O(N) 그러나 캐쉬 미스가 빈번하여 배열에 비해 느림.**  
**삽입: 일반적으로 O(1), 최악의 경우 O(N)**  
**삭제: 일반적으로 O(1), 최악의 경우 O(N)**  
**탐색: 일반적으로 O(1), 최악의 경우 O(N)**  

해쉬맵은 순회가 느린대신 삽입, 삭제, 탐색에 있어서 매우 우수한 성능을 보여줍니다. 그래서 굳이 순회가 필요하지않다면 해쉬맵은 일반적으로 좋은 선택이며, 가장 널리 사용되는 컨테이너입니다. 그러나 가장 중요한 토픽은 컨테이너의 순회이므로 해쉬맵을 오브젝트를 관리하는 컨테이너로는 사용하기는 어렵습니다. 대신 순회용으로는 백터, 탐색용으로는 해쉬맵, 삽입과 삭제의 오버헤드는 오브젝트 풀링으로 해결하는 형태를 갖춘다면 빠른 순회, O(1)의 탐색을 기대할 수 있습니다.

해당 방식의 단점은 다음과 같습니다.
1. 오브젝트 생성과 삭제에 있어 오브젝트 풀링 기법 강제
2. 느린 실시간 오브젝트 생성, 삭제
3. 벡터와 해쉬맵의 동기화 문제

먼저 하나 씩 살펴보겠습니다.
2번 문제 때문에 1번 문제가 발생하는 것이기에 2개의 문제점은 하나로 묶어서 볼 수 있습니다.
생성
